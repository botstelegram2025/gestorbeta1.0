#!/usr/bin/env python3
"""
Bot Telegram - Sistema de Gest√£o de Clientes - VERS√ÉO COMPLETA
Sistema completo com cobran√ßa Baileys, mensagens autom√°ticas e templates edit√°veis
"""

import os
import sys
import logging
from datetime import datetime, timedelta
import pytz
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ConversationHandler, CallbackQueryHandler
from telegram import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from database import DatabaseManager
from scheduler import MessageScheduler
from templates import TemplateManager
from baileys_api import BaileysAPI
from utils import *
import asyncio

# Configurar timezone brasileiro
TIMEZONE_BR = pytz.timezone('America/Sao_Paulo')

# Configurar logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO)
logger = logging.getLogger(__name__)

# Estados da conversa√ß√£o para cadastro de cliente
NOME, TELEFONE, PACOTE, VALOR, SERVIDOR, VENCIMENTO, CONFIRMAR = range(7)

# Estados para edi√ß√£o de cliente
EDIT_NOME, EDIT_TELEFONE, EDIT_PACOTE, EDIT_VALOR, EDIT_SERVIDOR, EDIT_VENCIMENTO = range(7, 13)

# Estados para configura√ß√µes
CONFIG_EMPRESA, CONFIG_PIX, CONFIG_SUPORTE = range(13, 16)

# Estados para edi√ß√£o de templates
TEMPLATE_EDIT_CONTENT = 16

# Estados para cria√ß√£o de novos templates
TEMPLATE_NEW_NAME, TEMPLATE_NEW_CONTENT = 17, 18

# Estados para envio manual de mensagens
SEND_MESSAGE_SELECT_CLIENT, SEND_MESSAGE_TYPE, SEND_MESSAGE_CUSTOM = range(19, 22)

# Inst√¢ncias globais - ser√£o inicializadas no main
db = None
scheduler = None
template_manager = None
baileys_api = None

def verificar_admin(func):
    """Decorator para verificar se √© admin"""
    async def wrapper(update, context):
        admin_id = int(os.getenv('ADMIN_CHAT_ID', '0'))
        if update.effective_chat.id != admin_id:
            await update.message.reply_text(
                "‚ùå Acesso negado. Apenas o admin pode usar este bot.")
            return
        return await func(update, context)
    return wrapper

@verificar_admin
async def start(update, context):
    """Comando /start"""
    nome_admin = update.effective_user.first_name
    
    try:
        total_clientes = len(db.listar_clientes(apenas_ativos=True))
        # Admin v√™ todos os clientes (sem filtro de usu√°rio)
        clientes_vencendo = len(db.listar_clientes_vencendo(dias=7, chat_id_usuario=None))
    except Exception as e:
        logger.error(f"Erro ao buscar estat√≠sticas: {e}")
        total_clientes = 0
        clientes_vencendo = 0

    mensagem = f"""ü§ñ *Bot de Gest√£o de Clientes*

Ol√° *{nome_admin}*! 

‚úÖ Sistema inicializado com sucesso!
üìä Total de clientes: {total_clientes}
‚ö†Ô∏è Vencimentos pr√≥ximos (7 dias): {clientes_vencendo}

Use os bot√µes abaixo para navegar:
üë• *Gest√£o de Clientes* - Gerenciar clientes
üì± *WhatsApp/Baileys* - Sistema de cobran√ßa
üìÑ *Templates* - Gerenciar mensagens
‚è∞ *Agendador* - Mensagens autom√°ticas
üìä *Relat√≥rios* - Estat√≠sticas do sistema

üöÄ Sistema 100% operacional!"""

    await update.message.reply_text(mensagem,
                                    parse_mode='Markdown',
                                    reply_markup=criar_teclado_principal())

# === SISTEMA DE CADASTRO ESCALON√ÅVEL ===

@verificar_admin
async def iniciar_cadastro(update, context):
    """Inicia o processo de cadastro de cliente"""
    await update.message.reply_text(
        "üìù *Cadastro de Novo Cliente*\n\n"
        "Vamos cadastrar um cliente passo a passo.\n\n"
        "**Passo 1/6:** Digite o *nome completo* do cliente:",
        parse_mode='Markdown',
        reply_markup=criar_teclado_cancelar())
    return NOME

async def receber_nome(update, context):
    """Recebe o nome do cliente"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    nome = update.message.text.strip()
    if len(nome) < 2:
        await update.message.reply_text(
            "‚ùå Nome muito curto. Digite um nome v√°lido:",
            reply_markup=criar_teclado_cancelar())
        return NOME

    context.user_data['nome'] = nome

    await update.message.reply_text(
        f"‚úÖ Nome: *{nome}*\n\n"
        "**Passo 2/6:** Digite o *telefone* (apenas n√∫meros):\n\n"
        "*Exemplo:* 11999999999",
        parse_mode='Markdown',
        reply_markup=criar_teclado_cancelar())
    return TELEFONE

async def receber_telefone(update, context):
    """Recebe o telefone do cliente"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    telefone = update.message.text.strip().replace(' ', '').replace('-', '').replace('(', '').replace(')', '')

    if not telefone.isdigit() or len(telefone) < 10:
        await update.message.reply_text(
            "‚ùå Telefone inv√°lido. Digite apenas n√∫meros (ex: 11999999999):",
            reply_markup=criar_teclado_cancelar())
        return TELEFONE

    # Verificar se telefone j√° existe
    cliente_existente = db.buscar_cliente_por_telefone(telefone)
    if cliente_existente:
        await update.message.reply_text(
            f"‚ùå J√° existe um cliente cadastrado com este telefone:\n"
            f"*{cliente_existente['nome']}*\n\n"
            "Digite outro telefone ou cancele:",
            parse_mode='Markdown',
            reply_markup=criar_teclado_cancelar())
        return TELEFONE

    context.user_data['telefone'] = telefone

    await update.message.reply_text(
        f"‚úÖ Telefone: *{telefone}*\n\n"
        "**Passo 3/6:** Escolha o *plano de dura√ß√£o*:\n\n"
        "Selecione uma das op√ß√µes ou digite um plano personalizado:",
        parse_mode='Markdown',
        reply_markup=criar_teclado_planos())
    return PACOTE

async def receber_pacote(update, context):
    """Recebe o pacote do cliente"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    texto = update.message.text.strip()

    # Processar bot√µes de planos predefinidos
    if texto == "üìÖ 1 m√™s":
        pacote = "Plano 1 m√™s"
    elif texto == "üìÖ 3 meses":
        pacote = "Plano 3 meses"
    elif texto == "üìÖ 6 meses":
        pacote = "Plano 6 meses"
    elif texto == "üìÖ 1 ano":
        pacote = "Plano 1 ano"
    elif texto == "‚úèÔ∏è Personalizado":
        await update.message.reply_text(
            "‚úèÔ∏è Digite o nome do seu plano personalizado:\n\n"
            "*Exemplos:* Netflix Premium, Disney+ 4K, Combo Streaming",
            parse_mode='Markdown',
            reply_markup=criar_teclado_cancelar())
        return PACOTE
    else:
        # Plano personalizado digitado diretamente
        pacote = texto
        if len(pacote) < 2:
            await update.message.reply_text(
                "‚ùå Nome do pacote muito curto. Digite um nome v√°lido:",
                reply_markup=criar_teclado_planos())
            return PACOTE

    context.user_data['pacote'] = pacote

    # Calcular data de vencimento autom√°tica baseada no plano
    hoje = agora_br().replace(tzinfo=None)
    duracao_msg = ""

    if "1 m√™s" in pacote:
        vencimento_auto = hoje + timedelta(days=30)
        duracao_msg = " (vence em 30 dias)"
    elif "3 meses" in pacote:
        vencimento_auto = hoje + timedelta(days=90)
        duracao_msg = " (vence em 90 dias)"
    elif "6 meses" in pacote:
        vencimento_auto = hoje + timedelta(days=180)
        duracao_msg = " (vence em 180 dias)"
    elif "1 ano" in pacote:
        vencimento_auto = hoje + timedelta(days=365)
        duracao_msg = " (vence em 1 ano)"
    else:
        vencimento_auto = hoje + timedelta(days=30)  # Padr√£o: 30 dias
        duracao_msg = " (vencimento padr√£o: 30 dias)"

    # Salvar data calculada automaticamente
    context.user_data['vencimento_auto'] = vencimento_auto.strftime('%Y-%m-%d')

    await update.message.reply_text(
        f"‚úÖ Pacote: *{pacote}*{duracao_msg}\n\n"
        "**Passo 4/6:** Escolha o *valor mensal*:\n\n"
        "Selecione um valor ou digite um personalizado:",
        parse_mode='Markdown',
        reply_markup=criar_teclado_valores())
    return VALOR

async def receber_valor(update, context):
    """Recebe o valor do plano"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    texto = update.message.text.strip()

    # Processar bot√µes de valores predefinidos
    if texto == "üí∞ R$ 30,00":
        valor = 30.00
    elif texto == "üí∞ R$ 35,00":
        valor = 35.00
    elif texto == "üí∞ R$ 40,00":
        valor = 40.00
    elif texto == "üí∞ R$ 45,00":
        valor = 45.00
    elif texto == "üí∞ R$ 50,00":
        valor = 50.00
    elif texto == "üí∞ R$ 60,00":
        valor = 60.00
    elif texto == "üí∞ R$ 70,00":
        valor = 70.00
    elif texto == "üí∞ R$ 90,00":
        valor = 90.00
    elif texto == "üí∞ R$ 135,00":
        valor = 135.00
    elif texto == "‚úèÔ∏è Valor personalizado":
        await update.message.reply_text(
            "‚úèÔ∏è Digite o valor personalizado:\n\n"
            "*Exemplos:* 25.50, 80, 120.00",
            reply_markup=criar_teclado_cancelar())
        return VALOR
    else:
        # Valor personalizado digitado
        try:
            valor_texto = texto.replace('R$', '').replace(',', '.').strip()
            valor = float(valor_texto)
            if valor <= 0:
                raise ValueError("Valor deve ser positivo")
        except ValueError:
            await update.message.reply_text(
                "‚ùå Valor inv√°lido. Digite um n√∫mero v√°lido (ex: 45.50):",
                reply_markup=criar_teclado_valores())
            return VALOR

    context.user_data['valor'] = valor

    await update.message.reply_text(
        f"‚úÖ Valor: *R$ {valor:.2f}*\n\n"
        "**Passo 5/6:** Digite o *servidor/login* do cliente:\n\n"
        "*Exemplo:* user123, cliente@email.com",
        parse_mode='Markdown',
        reply_markup=criar_teclado_cancelar())
    return SERVIDOR

async def receber_servidor(update, context):
    """Recebe o servidor/login do cliente"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    servidor = update.message.text.strip()
    if len(servidor) < 2:
        await update.message.reply_text(
            "‚ùå Servidor muito curto. Digite um servidor v√°lido:",
            reply_markup=criar_teclado_cancelar())
        return SERVIDOR

    context.user_data['servidor'] = servidor

    # Mostrar data de vencimento calculada automaticamente
    vencimento_auto = context.user_data['vencimento_auto']
    data_formatada = formatar_data_br(vencimento_auto)

    await update.message.reply_text(
        f"‚úÖ Servidor: *{servidor}*\n\n"
        "**Passo 6/6:** Data de vencimento:\n\n"
        f"üìÖ *Data calculada automaticamente:* {data_formatada}\n\n"
        "Deseja usar esta data ou personalizar?",
        parse_mode='Markdown',
        reply_markup=criar_teclado_vencimento())
    return VENCIMENTO

async def receber_vencimento(update, context):
    """Recebe a data de vencimento"""
    if update.message.text == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)

    texto = update.message.text.strip()

    if texto == "‚úÖ Usar data autom√°tica":
        vencimento = context.user_data['vencimento_auto']
    elif texto == "üìÖ Data personalizada":
        await update.message.reply_text(
            "üìÖ Digite a data de vencimento personalizada:\n\n"
            "*Formato:* DD/MM/AAAA\n"
            "*Exemplo:* 15/02/2024",
            reply_markup=criar_teclado_cancelar())
        return VENCIMENTO
    else:
        # Data personalizada digitada
        try:
            vencimento_dt = datetime.strptime(texto, '%d/%m/%Y')
            hoje = agora_br().replace(tzinfo=None)
            
            if vencimento_dt.date() < hoje.date():
                await update.message.reply_text(
                    "‚ùå Data n√£o pode ser anterior a hoje. Digite uma data v√°lida:",
                    reply_markup=criar_teclado_vencimento())
                return VENCIMENTO
                
            vencimento = vencimento_dt.strftime('%Y-%m-%d')
        except ValueError:
            await update.message.reply_text(
                "‚ùå Data inv√°lida. Use o formato DD/MM/AAAA:",
                reply_markup=criar_teclado_vencimento())
            return VENCIMENTO

    context.user_data['vencimento'] = vencimento

    # Mostrar resumo para confirma√ß√£o
    dados = context.user_data
    resumo = f"""üìã *RESUMO DO CLIENTE*

üë§ **Nome:** {dados['nome']}
üìû **Telefone:** {dados['telefone']}
üì¶ **Pacote:** {dados['pacote']}
üí∞ **Valor:** R$ {dados['valor']:.2f}
üñ•Ô∏è **Servidor:** {dados['servidor']}
üìÖ **Vencimento:** {formatar_data_br(dados['vencimento'])}

Confirma o cadastro?"""

    await update.message.reply_text(resumo,
                                    parse_mode='Markdown',
                                    reply_markup=criar_teclado_confirmar())
    return CONFIRMAR

async def confirmar_cadastro(update, context):
    """Confirma e salva o cadastro do cliente"""
    texto = update.message.text.strip()

    if texto == "‚ùå Cancelar":
        return await cancelar_cadastro(update, context)
    elif texto == "‚úèÔ∏è Editar":
        await update.message.reply_text(
            "‚úèÔ∏è Qual campo deseja editar?",
            reply_markup=criar_teclado_edicao())
        return CONFIRMAR
    elif texto == "‚úÖ Confirmar":
        try:
            dados = context.user_data
            
            # Cadastrar cliente no banco
            cliente_id = db.cadastrar_cliente(
                nome=dados['nome'],
                telefone=dados['telefone'],
                pacote=dados['pacote'],
                valor=dados['valor'],
                servidor=dados['servidor'],
                vencimento=dados['vencimento']
            )

            # Agendar mensagens autom√°ticas
            scheduler.agendar_mensagens_cliente(cliente_id)

            # Limpar dados da sess√£o
            context.user_data.clear()

            mensagem_sucesso = f"""‚úÖ *CLIENTE CADASTRADO COM SUCESSO!*

üÜî **ID:** {cliente_id}
üë§ **Nome:** {dados['nome']}
üìû **Telefone:** {dados['telefone']}
üì¶ **Pacote:** {dados['pacote']}
üí∞ **Valor:** R$ {dados['valor']:.2f}
üñ•Ô∏è **Servidor:** {dados['servidor']}
üìÖ **Vencimento:** {formatar_data_br(dados['vencimento'])}

ü§ñ Mensagens autom√°ticas agendadas!
üì± Cliente ser√° notificado via WhatsApp nos prazos corretos."""

            await update.message.reply_text(mensagem_sucesso,
                                            parse_mode='Markdown',
                                            reply_markup=criar_teclado_principal())
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Erro ao cadastrar cliente: {e}")
            await update.message.reply_text(
                f"‚ùå Erro ao cadastrar cliente: {str(e)}\n\n"
                "Tente novamente ou entre em contato com o suporte.",
                reply_markup=criar_teclado_principal())
            return ConversationHandler.END

async def cancelar_cadastro(update, context):
    """Cancela o processo de cadastro"""
    context.user_data.clear()
    await update.message.reply_text(
        "‚ùå Cadastro cancelado.",
        reply_markup=criar_teclado_principal())
    return ConversationHandler.END

# === SISTEMA DE LISTAGEM E BUSCA ===

@verificar_admin
async def listar_clientes(update, context):
    """Lista todos os clientes"""
    try:
        clientes = db.listar_clientes(apenas_ativos=True)
        
        if not clientes:
            await update.message.reply_text(
                "üì≠ Nenhum cliente cadastrado ainda.\n\n"
                "Use ‚ûï *Adicionar Cliente* para come√ßar!",
                parse_mode='Markdown',
                reply_markup=criar_teclado_principal())
            return

        # Dividir em p√°ginas se necess√°rio
        CLIENTES_POR_PAGINA = 10
        total_paginas = (len(clientes) + CLIENTES_POR_PAGINA - 1) // CLIENTES_POR_PAGINA
        
        pagina = int(context.args[0]) if context.args and context.args[0].isdigit() else 1
        pagina = max(1, min(pagina, total_paginas))
        
        inicio = (pagina - 1) * CLIENTES_POR_PAGINA
        fim = inicio + CLIENTES_POR_PAGINA
        clientes_pagina = clientes[inicio:fim]

        mensagem = f"üë• *LISTA DE CLIENTES* (P√°gina {pagina}/{total_paginas})\n\n"
        
        for i, cliente in enumerate(clientes_pagina, start=inicio + 1):
            venc_formatado = formatar_data_br(cliente['vencimento'])
            status_venc = "üî¥" if cliente['dias_vencimento'] < 0 else "üü°" if cliente['dias_vencimento'] <= 3 else "üü¢"
            
            mensagem += f"{i}. {status_venc} *{cliente['nome']}*\n"
            mensagem += f"   üìû {cliente['telefone']}\n"
            mensagem += f"   üì¶ {cliente['pacote']}\n"
            mensagem += f"   üí∞ R$ {cliente['valor']:.2f}\n"
            mensagem += f"   üìÖ {venc_formatado}\n"
            mensagem += f"   üÜî ID: {cliente['id']}\n\n"

        # Bot√µes de navega√ß√£o
        keyboard = []
        nav_buttons = []
        
        if pagina > 1:
            nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"lista_page_{pagina-1}"))
        if pagina < total_paginas:
            nav_buttons.append(InlineKeyboardButton("‚û°Ô∏è Pr√≥ximo", callback_data=f"lista_page_{pagina+1}"))
            
        if nav_buttons:
            keyboard.append(nav_buttons)
            
        keyboard.append([InlineKeyboardButton("üîç Buscar Cliente", callback_data="buscar_cliente")])
        keyboard.append([InlineKeyboardButton("‚ûï Adicionar Cliente", callback_data="adicionar_cliente")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Erro ao listar clientes: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao listar clientes: {str(e)}",
            reply_markup=criar_teclado_principal())

@verificar_admin
async def buscar_cliente(update, context):
    """Busca cliente por nome ou telefone"""
    if not context.args:
        await update.message.reply_text(
            "üîç *Buscar Cliente*\n\n"
            "Digite o nome ou telefone para buscar:\n\n"
            "*Exemplos:*\n"
            "‚Ä¢ `/buscar Jo√£o`\n"
            "‚Ä¢ `/buscar 11999999999`",
            parse_mode='Markdown')
        return

    termo = ' '.join(context.args)
    try:
        clientes = db.buscar_clientes(termo)
        
        if not clientes:
            await update.message.reply_text(
                f"üîç Nenhum cliente encontrado com: *{termo}*",
                parse_mode='Markdown',
                reply_markup=criar_teclado_principal())
            return

        mensagem = f"üîç *RESULTADOS DA BUSCA:* {termo}\n\n"
        
        for cliente in clientes[:10]:  # Limitar a 10 resultados
            venc_formatado = formatar_data_br(cliente['vencimento'])
            status_venc = "üî¥" if cliente['dias_vencimento'] < 0 else "üü°" if cliente['dias_vencimento'] <= 3 else "üü¢"
            
            mensagem += f"{status_venc} *{cliente['nome']}*\n"
            mensagem += f"üìû {cliente['telefone']}\n"
            mensagem += f"üì¶ {cliente['pacote']}\n"
            mensagem += f"üí∞ R$ {cliente['valor']:.2f}\n"
            mensagem += f"üìÖ {venc_formatado}\n"
            mensagem += f"üÜî ID: {cliente['id']}\n\n"

        if len(clientes) > 10:
            mensagem += f"... e mais {len(clientes) - 10} resultado(s)"

        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=criar_teclado_principal())

    except Exception as e:
        logger.error(f"Erro ao buscar cliente: {e}")
        await update.message.reply_text(
            f"‚ùå Erro na busca: {str(e)}",
            reply_markup=criar_teclado_principal())

# === SISTEMA DE RELAT√ìRIOS ===

@verificar_admin
async def relatorios(update, context):
    """Mostra relat√≥rios e estat√≠sticas"""
    try:
        stats = db.obter_estatisticas()
        
        mensagem = f"""üìä *RELAT√ìRIOS E ESTAT√çSTICAS*

üë• **Clientes:**
‚Ä¢ Total ativo: {stats['total_clientes']}
‚Ä¢ Novos este m√™s: {stats['novos_mes']}

üí∞ **Financeiro:**
‚Ä¢ Receita mensal: R$ {stats['receita_mensal']:.2f}
‚Ä¢ Receita anual: R$ {stats['receita_anual']:.2f}

‚ö†Ô∏è **Vencimentos:**
‚Ä¢ Vencidos: {stats['vencidos']} clientes
‚Ä¢ Vencem hoje: {stats['vencem_hoje']} clientes
‚Ä¢ Vencem em 3 dias: {stats['vencem_3dias']} clientes
‚Ä¢ Vencem esta semana: {stats['vencem_semana']} clientes

üì± **WhatsApp/Baileys:**
‚Ä¢ Status: {baileys_api.get_status()}
‚Ä¢ Mensagens enviadas hoje: {stats['mensagens_hoje']}
‚Ä¢ Fila de mensagens: {stats['fila_mensagens']}

üìÑ **Templates:**
‚Ä¢ Total de templates: {stats['total_templates']}
‚Ä¢ Mais usado: {stats['template_mais_usado']}"""

        keyboard = [
            [InlineKeyboardButton("üìà Relat√≥rio Detalhado", callback_data="relatorio_detalhado")],
            [InlineKeyboardButton("üìä Exportar Dados", callback_data="exportar_dados")],
            [InlineKeyboardButton("üîÑ Atualizar", callback_data="atualizar_stats")]
        ]
        
        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao gerar relat√≥rios: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao gerar relat√≥rios: {str(e)}",
            reply_markup=criar_teclado_principal())

# === SISTEMA DE TEMPLATES ===

@verificar_admin
async def gerenciar_templates(update, context):
    """Gerencia templates de mensagens"""
    try:
        templates = template_manager.listar_templates()
        
        mensagem = "üìÑ *GERENCIAR TEMPLATES*\n\n"
        
        if not templates:
            mensagem += "üì≠ Nenhum template criado ainda.\n\n"
        else:
            for template in templates:
                mensagem += f"‚Ä¢ *{template['nome']}*\n"
                mensagem += f"  üìù {template['descricao']}\n"
                mensagem += f"  üìä Usado {template['uso_count']} vez(es)\n\n"

        keyboard = [
            [InlineKeyboardButton("‚ûï Novo Template", callback_data="novo_template")],
            [InlineKeyboardButton("‚úèÔ∏è Editar Template", callback_data="editar_template")],
            [InlineKeyboardButton("üóëÔ∏è Excluir Template", callback_data="excluir_template")],
            [InlineKeyboardButton("üëÄ Visualizar Template", callback_data="visualizar_template")]
        ]
        
        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao gerenciar templates: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao gerenciar templates: {str(e)}",
            reply_markup=criar_teclado_principal())

# === SISTEMA DE AGENDAMENTO ===

@verificar_admin
async def gerenciar_agendador(update, context):
    """Gerencia o sistema de agendamento"""
    try:
        tarefas_pendentes = scheduler.obter_tarefas_pendentes()
        proximas_execucoes = scheduler.obter_proximas_execucoes(limit=5)
        
        mensagem = f"""‚è∞ *SISTEMA DE AGENDAMENTO*

üìä **Status:**
‚Ä¢ Agendador: {'üü¢ Ativo' if scheduler.is_running() else 'üî¥ Inativo'}
‚Ä¢ Tarefas pendentes: {len(tarefas_pendentes)}
‚Ä¢ √öltima verifica√ß√£o: {scheduler.ultima_verificacao()}

üìÖ **Pr√≥ximas Execu√ß√µes:**
"""
        
        for execucao in proximas_execucoes:
            mensagem += f"‚Ä¢ {execucao['data']} - {execucao['tipo']} - {execucao['cliente']}\n"
            
        if not proximas_execucoes:
            mensagem += "‚Ä¢ Nenhuma execu√ß√£o agendada\n"

        keyboard = [
            [InlineKeyboardButton("‚ñ∂Ô∏è Iniciar Agendador", callback_data="start_scheduler")],
            [InlineKeyboardButton("‚è∏Ô∏è Pausar Agendador", callback_data="pause_scheduler")],
            [InlineKeyboardButton("üîÑ Reagendar Todos", callback_data="reagendar_todos")],
            [InlineKeyboardButton("üìã Ver Fila Completa", callback_data="ver_fila_completa")]
        ]
        
        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao gerenciar agendador: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao gerenciar agendador: {str(e)}",
            reply_markup=criar_teclado_principal())

# === SISTEMA WHATSAPP/BAILEYS ===

@verificar_admin
async def whatsapp_status(update, context):
    """Mostra status do WhatsApp/Baileys"""
    try:
        status = baileys_api.get_status()
        qr_needed = baileys_api.qr_code_needed()
        
        mensagem = f"""üì± *STATUS WHATSAPP/BAILEYS*

üîó **Conex√£o:** {status['status']}
üìû **N√∫mero:** {status.get('numero', 'N√£o conectado')}
üîã **Bateria:** {status.get('bateria', 'N/A')}%
üì∂ **√öltima conex√£o:** {status.get('ultima_conexao', 'N/A')}

üìä **Estat√≠sticas de hoje:**
‚Ä¢ Mensagens enviadas: {status.get('mensagens_enviadas', 0)}
‚Ä¢ Mensagens falharam: {status.get('mensagens_falharam', 0)}
‚Ä¢ Fila pendente: {status.get('fila_pendente', 0)}

{"üì∑ QR Code necess√°rio para reconex√£o!" if qr_needed else "‚úÖ Dispositivo conectado!"}"""

        keyboard = []
        
        if qr_needed:
            keyboard.append([InlineKeyboardButton("üì∑ Gerar QR Code", callback_data="gerar_qr")])
        
        keyboard.extend([
            [InlineKeyboardButton("üß™ Testar Envio", callback_data="testar_whatsapp")],
            [InlineKeyboardButton("üîÑ Reconectar", callback_data="reconectar_whatsapp")],
            [InlineKeyboardButton("üì± Configura√ß√µes", callback_data="config_whatsapp")]
        ])
        
        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao verificar status WhatsApp: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao verificar status: {str(e)}",
            reply_markup=criar_teclado_principal())

@verificar_admin
async def gerar_qr_code(update, context):
    """Gera QR Code para conex√£o WhatsApp"""
    try:
        await update.message.reply_text("üì∑ Gerando QR Code para WhatsApp...")
        
        qr_data = baileys_api.generate_qr_code()
        
        if qr_data and qr_data.get('qr_code'):
            # Enviar QR Code como imagem
            await update.message.reply_photo(
                photo=qr_data['qr_code'],
                caption="üì± *Escaneie este QR Code com o WhatsApp*\n\n"
                       "1. Abra o WhatsApp no seu celular\n"
                       "2. Toque em Menu > Dispositivos conectados\n"
                       "3. Toque em 'Conectar um dispositivo'\n"
                       "4. Escaneie este c√≥digo\n\n"
                       "‚è∞ QR Code expira em 20 segundos",
                parse_mode='Markdown')
        else:
            await update.message.reply_text(
                "‚ùå Erro ao gerar QR Code. Tente novamente.",
                reply_markup=criar_teclado_principal())

    except Exception as e:
        logger.error(f"Erro ao gerar QR Code: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao gerar QR Code: {str(e)}",
            reply_markup=criar_teclado_principal())

@verificar_admin
async def testar_whatsapp(update, context):
    """Testa envio de mensagem WhatsApp"""
    try:
        # Pegar n√∫mero do admin
        admin_phone = os.getenv('ADMIN_PHONE')
        if not admin_phone:
            await update.message.reply_text(
                "‚ùå N√∫mero do admin n√£o configurado.\n"
                "Configure a vari√°vel ADMIN_PHONE no ambiente.",
                reply_markup=criar_teclado_principal())
            return

        await update.message.reply_text("üß™ Enviando mensagem de teste...")
        
        resultado = baileys_api.send_message(
            phone=admin_phone,
            message="üß™ Teste do Sistema de Cobran√ßa\n\n"
                   "Esta √© uma mensagem de teste do bot de gest√£o de clientes.\n\n"
                   f"‚úÖ Sistema funcionando corretamente!\n"
                   f"üïê {formatar_datetime_br(agora_br())}"
        )
        
        if resultado['success']:
            await update.message.reply_text(
                "‚úÖ Mensagem de teste enviada com sucesso!\n\n"
                f"üì± Enviado para: {admin_phone}\n"
                f"üÜî ID da mensagem: {resultado.get('message_id', 'N/A')}",
                reply_markup=criar_teclado_principal())
        else:
            await update.message.reply_text(
                f"‚ùå Falha no envio de teste:\n{resultado.get('error', 'Erro desconhecido')}",
                reply_markup=criar_teclado_principal())

    except Exception as e:
        logger.error(f"Erro no teste WhatsApp: {e}")
        await update.message.reply_text(
            f"‚ùå Erro no teste: {str(e)}",
            reply_markup=criar_teclado_principal())

# === SISTEMA DE ENVIO MANUAL ===

@verificar_admin
async def envio_manual(update, context):
    """Inicia processo de envio manual de mensagem"""
    try:
        clientes = db.listar_clientes(apenas_ativos=True)
        
        if not clientes:
            await update.message.reply_text(
                "üì≠ Nenhum cliente cadastrado para envio.",
                reply_markup=criar_teclado_principal())
            return ConversationHandler.END

        # Criar lista de clientes para sele√ß√£o
        mensagem = "üë• *ENVIO MANUAL DE MENSAGEM*\n\n"
        mensagem += "Selecione o cliente ou digite o ID:\n\n"
        
        keyboard = []
        for i, cliente in enumerate(clientes[:10]):  # Limitar a 10 para n√£o ficar muito grande
            keyboard.append([InlineKeyboardButton(
                f"{cliente['nome']} - {cliente['telefone']}", 
                callback_data=f"select_client_{cliente['id']}"
            )])
        
        if len(clientes) > 10:
            keyboard.append([InlineKeyboardButton("üìÑ Ver todos os clientes", callback_data="ver_todos_clientes")])
            
        keyboard.append([InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_envio")])
        
        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))
        return SEND_MESSAGE_SELECT_CLIENT

    except Exception as e:
        logger.error(f"Erro no envio manual: {e}")
        await update.message.reply_text(
            f"‚ùå Erro no envio manual: {str(e)}",
            reply_markup=criar_teclado_principal())
        return ConversationHandler.END

# === HANDLERS DE CALLBACK ===

async def handle_callback(update, context):
    """Handle para bot√µes inline"""
    query = update.callback_query
    await query.answer()
    
    data = query.data
    
    try:
        # Navega√ß√£o da lista de clientes
        if data.startswith('lista_page_'):
            pagina = int(data.split('_')[2])
            context.args = [str(pagina)]
            return await listar_clientes(update, context)
        
        # Sele√ß√£o de cliente para envio
        elif data.startswith('select_client_'):
            cliente_id = int(data.split('_')[2])
            context.user_data['cliente_selecionado'] = cliente_id
            
            # Mostrar op√ß√µes de template
            templates = template_manager.listar_templates()
            
            mensagem = "üìÑ *Escolha o tipo de mensagem:*\n\n"
            
            keyboard = []
            for template in templates:
                keyboard.append([InlineKeyboardButton(
                    template['nome'], 
                    callback_data=f"template_{template['id']}"
                )])
            
            keyboard.append([InlineKeyboardButton("‚úèÔ∏è Mensagem personalizada", callback_data="mensagem_custom")])
            keyboard.append([InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_envio")])
            
            await query.edit_message_text(mensagem,
                                         parse_mode='Markdown',
                                         reply_markup=InlineKeyboardMarkup(keyboard))
            return SEND_MESSAGE_TYPE
        
        # Sele√ß√£o de template
        elif data.startswith('template_'):
            template_id = int(data.split('_')[1])
            cliente_id = context.user_data['cliente_selecionado']
            
            # Buscar dados do cliente e template
            cliente = db.buscar_cliente_por_id(cliente_id)
            template = template_manager.obter_template(template_id)
            
            # Processar template com dados do cliente
            mensagem_processada = template_manager.processar_template(template['conteudo'], cliente)
            
            # Confirmar envio
            mensagem_confirmacao = f"""üì± *CONFIRMAR ENVIO*

üë§ **Cliente:** {cliente['nome']}
üìû **Telefone:** {cliente['telefone']}
üìÑ **Template:** {template['nome']}

üí¨ **Mensagem que ser√° enviada:**
{mensagem_processada}

Confirma o envio?"""

            keyboard = [
                [InlineKeyboardButton("‚úÖ Confirmar Envio", callback_data=f"confirm_send_{cliente_id}_{template_id}")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_envio")]
            ]
            
            await query.edit_message_text(mensagem_confirmacao,
                                         parse_mode='Markdown',
                                         reply_markup=InlineKeyboardMarkup(keyboard))
        
        # Confirmar envio
        elif data.startswith('confirm_send_'):
            parts = data.split('_')
            cliente_id = int(parts[2])
            template_id = int(parts[3])
            
            cliente = db.buscar_cliente_por_id(cliente_id)
            template = template_manager.obter_template(template_id)
            mensagem_processada = template_manager.processar_template(template['conteudo'], cliente)
            
            # Enviar mensagem
            resultado = baileys_api.send_message(
                phone=cliente['telefone'],
                message=mensagem_processada
            )
            
            if resultado['success']:
                # Registrar envio no banco
                (_:=None, __:=None)
                # Registrar com isolamento por usu√°rio quando suportado
                try:
                    db.registrar_envio_manual(cliente_id, template_id, mensagem_processada, chat_id_usuario=update.effective_chat.id)
                except TypeError:
                    db.registrar_envio_manual(cliente_id, template_id, mensagem_processada)
                
                await query.edit_message_text(
                    f"‚úÖ Mensagem enviada com sucesso!\n\n"
                    f"üë§ Cliente: {cliente['nome']}\n"
                    f"üìû Telefone: {cliente['telefone']}\n"
                    f"üÜî ID da mensagem: {resultado.get('message_id', 'N/A')}"
                )
            else:
                await query.edit_message_text(
                    f"‚ùå Falha no envio:\n{resultado.get('error', 'Erro desconhecido')}"
                )
        
        # Outros callbacks...
        elif data == "cancelar_envio":
            await query.edit_message_text("‚ùå Envio cancelado.")
        
        elif data == "gerar_qr":
            return await gerar_qr_code(update, context)
        
        elif data == "testar_whatsapp":
            return await testar_whatsapp(update, context)

    except Exception as e:
        logger.error(f"Erro no callback: {e}")
        await query.edit_message_text(f"‚ùå Erro: {str(e)}")

# === HANDLERS DE TEXTO ===

@verificar_admin
async def handle_message(update, context):
    """Handler para mensagens de texto (bot√µes do teclado)"""
    texto = update.message.text
    
    # Gest√£o de Clientes
    if texto == "üë• Listar Clientes":
        return await listar_clientes(update, context)
    elif texto == "‚ûï Adicionar Cliente":
        return await iniciar_cadastro(update, context)
    elif texto == "üîç Buscar Cliente":
        await update.message.reply_text(
            "üîç Digite o nome ou telefone para buscar:\n\n"
            "*Exemplo:* Jo√£o Silva ou 11999999999",
            parse_mode='Markdown')
        return
    elif texto == "üìä Relat√≥rios":
        return await relatorios(update, context)
    
    # Templates
    elif texto == "üìÑ Templates":
        return await gerenciar_templates(update, context)
    
    # Agendador
    elif texto == "‚è∞ Agendador":
        return await gerenciar_agendador(update, context)
    elif texto == "üìã Fila de Mensagens":
        return await ver_fila_mensagens(update, context)
    elif texto == "üìú Logs de Envios":
        return await ver_logs_envios(update, context)
    
    # WhatsApp
    elif texto == "üì± WhatsApp Status":
        return await whatsapp_status(update, context)
    elif texto == "üß™ Testar WhatsApp":
        return await testar_whatsapp(update, context)
    elif texto == "üì± QR Code":
        return await gerar_qr_code(update, context)
    elif texto == "‚öôÔ∏è Gerenciar WhatsApp":
        return await gerenciar_whatsapp(update, context)
    
    # Configura√ß√µes
    elif texto == "üè¢ Empresa":
        return await configurar_empresa(update, context)
    elif texto == "üí≥ PIX":
        return await configurar_pix(update, context)
    elif texto == "üìû Suporte":
        return await configurar_suporte(update, context)
    
    # Ajuda
    elif texto == "‚ùì Ajuda":
        return await mostrar_ajuda(update, context)
    
    # Envio manual
    elif texto == "üì§ Envio Manual":
        return await envio_manual(update, context)
    
    else:
        # Verificar se √© uma busca direta
        if len(texto) > 2:
            context.args = [texto]
            return await buscar_cliente(update, context)

# === FUN√á√ïES AUXILIARES ===


async def ver_fila_mensagens(update, context):
    """Mostra fila de mensagens pendentes (isolada por usu√°rio)."""
    try:
        chat_id = update.effective_chat.id

        # Tenta obter diretamente do DB filtrado por usu√°rio, se suportado
        fila = None
        try:
            fila = db.obter_mensagens_pendentes(limit=100, chat_id_usuario=chat_id)
        except TypeError:
            # Usa o scheduler e filtra manualmente
            fila = scheduler.obter_fila_mensagens()

        def _item_owner(item):
            # Tenta usar campo direto
            if isinstance(item, dict) and item.get('chat_id_usuario') is not None:
                return item.get('chat_id_usuario')
            # Caso contr√°rio, resolve pelo cliente_id
            cid = (item or {}).get('cliente_id')
            if cid:
                try:
                    cliente = db.buscar_cliente_por_id(cid)
                    return cliente.get('chat_id_usuario') if isinstance(cliente, dict) else None
                except Exception:
                    return None
            return None

        fila_filtrada = []
        for it in (fila or []):
            dono = _item_owner(it)
            if dono == chat_id:
                fila_filtrada.append(it)

        if not fila_filtrada:
            await update.message.reply_text(
                "üìã Fila de mensagens vazia para este usu√°rio.\n\n"
                "‚úÖ Nenhuma mensagem pendente agora.",
                reply_markup=criar_teclado_principal())
            return

        mensagem = f"üìã *FILA DE MENSAGENS* ({len(fila_filtrada)} pendentes)\n\n"
        for item in fila_filtrada[:10]:  # Mostrar apenas os 10 primeiros
            alvo = item.get('agendado_para')
            cli = item.get('cliente_nome') or '‚Äî'
            tel = item.get('telefone') or '‚Äî'
            tipo = item.get('tipo_mensagem') or '‚Äî'
            iid = item.get('id', '‚Äî')
            mensagem += f"‚è∞ {alvo}\n"
            mensagem += f"üë§ {cli}\n"
            mensagem += f"üì± {tel}\n"
            mensagem += f"üìÑ {tipo}\n"
            mensagem += f"üÜî ID: {iid}\n\n"

        if len(fila_filtrada) > 10:
            mensagem += f"... e mais {len(fila_filtrada) - 10} mensagens na fila"

        keyboard = [
            [InlineKeyboardButton("üîÑ Atualizar", callback_data="atualizar_fila")],
            [InlineKeyboardButton("‚è∏Ô∏è Pausar Fila", callback_data="pausar_fila")],
            [InlineKeyboardButton("üóëÔ∏è Limpar Fila", callback_data="limpar_fila")]
        ]

        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao ver fila: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao visualizar fila: {str(e)}",
            reply_markup=criar_teclado_principal())

async def ver_logs_envios(update, context):
    """Mostra logs de envios recentes (isolados por usu√°rio)."""
    try:
        chat_id = update.effective_chat.id
        # Tenta buscar j√° filtrando por usu√°rio, se o m√©todo aceitar
        try:
            logs = db.obter_logs_envios(limit=50, chat_id_usuario=chat_id)
        except TypeError:
            logs = db.obter_logs_envios(limit=50)

        # Filtro de seguran√ßa por usu√°rio (caso o m√©todo acima n√£o suporte)
        def _log_owner(log):
            # Se j√° vier com chat_id do dono, usa direto
            if isinstance(log, dict) and log.get('chat_id_usuario') is not None:
                return log.get('chat_id_usuario')
            # Caso contr√°rio, tenta resolver pelo cliente_id
            cid = (log or {}).get('cliente_id')
            if cid:
                try:
                    cliente = db.buscar_cliente_por_id(cid)
                    return cliente.get('chat_id_usuario') if isinstance(cliente, dict) else None
                except Exception:
                    return None
            return None

        logs_filtrados = []
        for l in (logs or []):
            dono = _log_owner(l)
            if dono is None:
                # Se n√£o for poss√≠vel identificar o dono, por seguran√ßa n√£o exibimos
                continue
            if dono == chat_id:
                logs_filtrados.append(l)

        if not logs_filtrados:
            await update.message.reply_text(
                "üìú Nenhum envio registrado ainda para este usu√°rio.",
                reply_markup=criar_teclado_principal())
            return

        # Renderiza√ß√£o
        mensagem = f"üìú *LOGS DE ENVIOS* (√∫ltimos {len(logs_filtrados)})\n\n"
        for log in logs_filtrados[:50]:
            status_icon = "‚úÖ" if log.get('sucesso') else "‚ùå"
            dt = log.get('data_envio', '-')
            mensagem += f"{status_icon} {dt}\n"
            if log.get('cliente_nome'):
                mensagem += f"üë§ {log.get('cliente_nome')}\n"
            if log.get('telefone'):
                mensagem += f"üì± {log.get('telefone')}\n"
            # Alguns bancos usam 'tipo' ou 'tipo_envio'
            tipo = log.get('tipo') or log.get('tipo_envio') or '‚Äî'
            mensagem += f"üìÑ {tipo}\n"
            if not log.get('sucesso') and log.get('erro'):
                mensagem += f"‚ö†Ô∏è Erro: {log.get('erro')}\n"
            mensagem += "\n"

        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=criar_teclado_principal())

    except Exception as e:
        logger.error(f"Erro ao ver logs: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao visualizar logs: {str(e)}",
            reply_markup=criar_teclado_principal())

async def gerenciar_whatsapp(update, context):
    """Gerencia configura√ß√µes avan√ßadas do WhatsApp"""
    try:
        config = baileys_api.get_config()
        
        mensagem = f"""‚öôÔ∏è *CONFIGURA√á√ïES WHATSAPP*

üîß **Configura√ß√µes atuais:**
‚Ä¢ Auto-reconectar: {config.get('auto_reconnect', False)}
‚Ä¢ Timeout mensagens: {config.get('message_timeout', 30)}s
‚Ä¢ M√°x. tentativas: {config.get('max_retries', 3)}
‚Ä¢ Intervalo entre mensagens: {config.get('message_interval', 2)}s

üìä **Estat√≠sticas:**
‚Ä¢ Sess√£o ativa h√°: {config.get('session_duration', 'N/A')}
‚Ä¢ Total de mensagens: {config.get('total_messages', 0)}
‚Ä¢ Taxa de sucesso: {config.get('success_rate', 0)}%"""

        keyboard = [
            [InlineKeyboardButton("üîÑ Auto-reconectar ON/OFF", callback_data="toggle_auto_reconnect")],
            [InlineKeyboardButton("‚è±Ô∏è Configurar Timeouts", callback_data="config_timeouts")],
            [InlineKeyboardButton("üîß Configura√ß√µes Avan√ßadas", callback_data="config_advanced")],
            [InlineKeyboardButton("üóëÔ∏è Limpar Sess√£o", callback_data="clear_session")]
        ]

        await update.message.reply_text(mensagem,
                                        parse_mode='Markdown',
                                        reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Erro ao gerenciar WhatsApp: {e}")
        await update.message.reply_text(
            f"‚ùå Erro ao gerenciar WhatsApp: {str(e)}",
            reply_markup=criar_teclado_principal())

async def configurar_empresa(update, context):
    """Configura dados da empresa"""
    await update.message.reply_text(
        "üè¢ *CONFIGURA√á√ïES DA EMPRESA*\n\n"
        "Em desenvolvimento...\n\n"
        "Esta funcionalidade permitir√° configurar:\n"
        "‚Ä¢ Nome da empresa\n"
        "‚Ä¢ Logo\n"
        "‚Ä¢ Dados de contato\n"
        "‚Ä¢ Informa√ß√µes para templates",
        parse_mode='Markdown',
        reply_markup=criar_teclado_principal())

async def configurar_pix(update, context):
    """Configura dados do PIX"""
    await update.message.reply_text(
        "üí≥ *CONFIGURA√á√ïES PIX*\n\n"
        "Em desenvolvimento...\n\n"
        "Esta funcionalidade permitir√° configurar:\n"
        "‚Ä¢ Chave PIX\n"
        "‚Ä¢ QR Code autom√°tico\n"
        "‚Ä¢ Dados do benefici√°rio\n"
        "‚Ä¢ Templates de cobran√ßa",
        parse_mode='Markdown',
        reply_markup=criar_teclado_principal())

async def configurar_suporte(update, context):
    """Configura dados de suporte"""
    await update.message.reply_text(
        "üìû *CONFIGURA√á√ïES DE SUPORTE*\n\n"
        "Em desenvolvimento...\n\n"
        "Esta funcionalidade permitir√° configurar:\n"
        "‚Ä¢ Telefone de suporte\n"
        "‚Ä¢ Email de contato\n"
        "‚Ä¢ Hor√°rio de atendimento\n"
        "‚Ä¢ Links √∫teis",
        parse_mode='Markdown',
        reply_markup=criar_teclado_principal())

async def mostrar_ajuda(update, context):
    """Mostra ajuda completa do sistema"""
    mensagem = """‚ùì *AJUDA COMPLETA DO SISTEMA*

ü§ñ **Bot de Gest√£o de Clientes**
Sistema completo para gest√£o de clientes com cobran√ßa autom√°tica via WhatsApp.

üë• **GEST√ÉO DE CLIENTES:**
‚Ä¢ `/start` - Iniciar o bot
‚Ä¢ `üë• Listar Clientes` - Ver todos os clientes
‚Ä¢ `‚ûï Adicionar Cliente` - Cadastro escalon√°vel
‚Ä¢ `üîç Buscar Cliente` - Buscar por nome/telefone
‚Ä¢ `/buscar <termo>` - Busca direta

üì± **WHATSAPP/BAILEYS:**
‚Ä¢ `üì± WhatsApp Status` - Ver status da conex√£o
‚Ä¢ `üì± QR Code` - Gerar c√≥digo para conectar
‚Ä¢ `üß™ Testar WhatsApp` - Enviar mensagem teste
‚Ä¢ `‚öôÔ∏è Gerenciar WhatsApp` - Configura√ß√µes avan√ßadas

üìÑ **TEMPLATES:**
‚Ä¢ `üìÑ Templates` - Gerenciar templates
‚Ä¢ Templates com vari√°veis: `{nome}`, `{telefone}`, `{valor}`, etc.

‚è∞ **AGENDAMENTO AUTOM√ÅTICO:**
‚Ä¢ Mensagens 2 dias antes do vencimento
‚Ä¢ Mensagem no dia do vencimento
‚Ä¢ Mensagem 1 dia ap√≥s vencimento
‚Ä¢ `‚è∞ Agendador` - Controlar sistema
‚Ä¢ `üìã Fila de Mensagens` - Ver pend√™ncias

üìä **RELAT√ìRIOS:**
‚Ä¢ `üìä Relat√≥rios` - Estat√≠sticas completas
‚Ä¢ `üìú Logs de Envios` - Hist√≥rico de mensagens

üîß **CONFIGURA√á√ïES:**
‚Ä¢ `üè¢ Empresa` - Dados da empresa
‚Ä¢ `üí≥ PIX` - Configurar cobran√ßa
‚Ä¢ `üìû Suporte` - Dados de contato

üÜò **SUPORTE:**
Entre em contato com o administrador do sistema para suporte t√©cnico."""

    await update.message.reply_text(mensagem,
                                    parse_mode='Markdown',
                                    reply_markup=criar_teclado_principal())

# === FUN√á√ÉO PRINCIPAL ===

async def main():
    """Fun√ß√£o principal do bot"""
    global db, scheduler, template_manager, baileys_api
    
    # Verificar vari√°veis de ambiente obrigat√≥rias
    bot_token = os.getenv('BOT_TOKEN')
    admin_chat_id = os.getenv('ADMIN_CHAT_ID')
    
    if not bot_token:
        logger.error("BOT_TOKEN n√£o encontrado nas vari√°veis de ambiente")
        sys.exit(1)
    
    if not admin_chat_id:
        logger.error("ADMIN_CHAT_ID n√£o encontrado nas vari√°veis de ambiente")
        sys.exit(1)

    try:
        # Inicializar componentes
        logger.info("Inicializando banco de dados...")
        db = DatabaseManager()
        
        logger.info("Inicializando sistema de templates...")
        template_manager = TemplateManager(db)
        
        logger.info("Inicializando API Baileys...")
        baileys_api = BaileysAPI()
        
        logger.info("Inicializando agendador...")
        scheduler = MessageScheduler(db, baileys_api, template_manager)
        
        # Criar aplica√ß√£o do bot
        application = Application.builder().token(bot_token).build()

        # Conversation handler para cadastro de cliente
        conv_handler_cadastro = ConversationHandler(
            entry_points=[MessageHandler(filters.Regex("^‚ûï Adicionar Cliente$"), iniciar_cadastro)],
            states={
                NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
                TELEFONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_telefone)],
                PACOTE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_pacote)],
                VALOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_valor)],
                SERVIDOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_servidor)],
                VENCIMENTO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_vencimento)],
                CONFIRMAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, confirmar_cadastro)]
            },
            fallbacks=[CommandHandler('cancel', cancelar_cadastro)]
        )

        # Conversation handler para envio manual
        conv_handler_envio = ConversationHandler(
            entry_points=[MessageHandler(filters.Regex("^üì§ Envio Manual$"), envio_manual)],
            states={
                SEND_MESSAGE_SELECT_CLIENT: [CallbackQueryHandler(handle_callback)],
                SEND_MESSAGE_TYPE: [CallbackQueryHandler(handle_callback)],
                SEND_MESSAGE_CUSTOM: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_callback)]
            },
            fallbacks=[CallbackQueryHandler(handle_callback, pattern="^cancelar_envio$")]
        )

        # Adicionar handlers
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("buscar", buscar_cliente))
        application.add_handler(conv_handler_cadastro)
        application.add_handler(conv_handler_envio)
        application.add_handler(CallbackQueryHandler(handle_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

        logger.info("Bot iniciado com sucesso!")
        
        # Iniciar agendador
        scheduler.start()
        
        # Executar bot
        await application.run_polling(allowed_updates=['message', 'callback_query'])

    except Exception as e:
        logger.error(f"Erro ao inicializar bot: {e}")
        sys.exit(1)

if __name__ == '__main__':
    asyncio.run(main())
